---                
layout: post                
title: "Express 框架"                
date:   2022-11-14 20:30:00                 
categories: "Web"                
catalog: true                
tags:                 
    - Web                
---      

# 介绍

Express 是一个简洁而灵活的 node.js Web应用框架, 提供一系列强大特性帮助你创建各种Web应用。Express 不对 node.js 已有的特性进行二次抽象，我们只是在它之上扩展了Web应用所需的功能。丰富的HTTP工具以及来自Connect框架的中间件随取随用，创建强健、友好的API变得快速又简单。  
Express 框架核心特性：  
1. 可以设置中间件来响应 HTTP 请求。  
2. 定义了路由表用于执行不同的 HTTP 请求动作。  
3. 可以通过向模板传递参数来动态渲染 HTML 页面。  


# 安装Express
Express 需要提前安装Node.js，创建目录以保存应用程序，并将其设置为工作目录。

    mkdir expressDemo
    cd expressDemo

    npm init -y  //以默认值初始化一个package.json
    npm i @types/node --save

    npm install express --save
    npm install @types/express --save

    npm install -g nodemon  //监视代码改动

    nodemon build/auction_server  //用nodemon启动服务

npm install ws --save
npm install @types/ws --save-dev

# Hello World
在 expressDemo 目录中，创建名为 index.js 的文件，然后添加以下代码：

    const express = require('express')
    const app = express()
    const port = 3000

    app.get('/', (req, res) => {
        res.send('Hello World!')
    })

    app.listen(port, () => {
        console.log(`Example app listening on port ${port}`)
    })

应用程序会启动H服务器，并在端口 3000 上侦听连接。此应用程序以“Hello World!”响应针对根 URL (/) 或路由的请求。  

使用以下命令运行应用程序：  

    node index.js

然后，在浏览器中输入 http://localhost:3000/ 以查看输出。  
也可以使用Express generator来快速创建一个应用程序框架.  
[Express 应用程序生成器](https://expressjs.com/zh-cn/starter/generator.html)

# 路由
路由用于确定应用程序如何响应对特定端点的客户机请求，包含一个 URI（或路径）和一个特定的 HTTP 请求方法（GET、POST 等）。  每个路由可以具有一个或多个处理程序函数，这些函数在路由匹配时执行。  
路由定义采用以下结构：  

    app.METHOD(PATH, HANDLER)

app 是 express 的实例。METHOD 是 HTTP 请求方法。PATH 是服务器上的路径。 HANDLER 是在路由匹配时执行的函数。  
在HelloWorld示例中：   

    app.get('/', function (req, res) {
        res.send('Hello World!');
    });

在根路由 (/) 上对 POST 请求进行响应：  

    app.post('/', function (req, res) {
        res.send('Got a POST request');
    });

Express 支持对应于 HTTP 方法的以下路由方法：get、post、put、head、delete、options、trace、copy、lock、mkcol、move、purge、propfind、proppatch、unlock、report、mkactivity、checkout、merge、m-search、notify、subscribe、unsubscribe、patch、search 和 connect。  

有一种特殊路由方法：app.all()，它并非派生自 HTTP 方法。该方法用于在所有请求方法的路径中装入中间件函数。  
在以下示例中，无论您使用 GET、POST、PUT、DELETE 还是在 http 模块中支持的其他任何 HTTP 请求方法，都将为针对“/secret”的请求执行处理程序。


    app.all('/secret', function (req, res, next) {
        console.log('Accessing the secret section ...');
        next(); // pass control to the next handler
    });

## 路由处理程序
可以提供多个回调函数，以类似于中间件的行为方式来处理请求。唯一例外是这些回调函数可能调用 next('route') 来绕过剩余的路由回调。您可以使用此机制对路由施加先决条件，在没有理由继续执行当前路由的情况下，可将控制权传递给后续路由。  
路由处理程序的形式可以是一个函数、一组函数或者两者的结合，如以下示例中所示。  
单个回调函数  

    app.get('/example/a', function (req, res) {
        res.send('Hello from A!');
    });

多个回调函数  

    app.get('/example/b', function (req, res, next) {
        console.log('the response will be sent by the next function ...');
        next();
    }, function (req, res) {
        res.send('Hello from B!');
    });

一组回调函数  

    var cb0 = function (req, res, next) {
        console.log('CB0');
        next();
    }

    var cb1 = function (req, res, next) {
        console.log('CB1');
     next();
    }

    var cb2 = function (req, res) {
        res.send('Hello from C!');
    }

    app.get('/example/c', [cb0, cb1, cb2]);

路由处理程序使您可以为一个路径定义多个路由。以下示例为针对 /user/:id 路径的 GET 请求定义两个路由。第二个路由不会导致任何问题，但是永远都不会被调用，因为第一个路由结束了请求/响应循环。

    app.get('/user/:id', function (req, res, next) {
        console.log('ID:', req.params.id);
        next();
    }, function (req, res, next) {
        res.send('User Info');
    });

    // handler for the /user/:id path, which prints the user ID
    app.get('/user/:id', function (req, res, next) {
        res.end(req.params.id);
    });

要跳过路由器中间件堆栈中剩余的中间件函数，请调用 next('route') 将控制权传递给下一个路由。 注：next('route') 仅在使用 app.METHOD() 或 router.METHOD() 函数装入的中间件函数中有效。  

    app.get('/user/:id', function (req, res, next) {
        // if the user ID is 0, skip to the next route
        if (req.params.id == 0) next('route');
        // otherwise pass the control to the next middleware function in this stack
        else next(); //
        }, function (req, res, next) {
            // render a regular page
            res.render('regular');
    });

    // handler for the /user/:id path, which renders a special page
    app.get('/user/:id', function (req, res, next) {
        res.render('special');
    });

## app.route()
可以使用 app.route() 为路由路径创建可链接的路由处理程序。 因为在单一位置指定路径，所以可以减少冗余和输入错误。  
以下是使用 app.route() 定义的链式路由处理程序的示例。  

    app.route('/book')
        .get(function(req, res) {
            res.send('Get a random book');
        })
        .post(function(req, res) {
            res.send('Add a book');
        })
        .put(function(req, res) {
            res.send('Update the book');
        });

## express.Router
使用 express.Router 类来创建可安装的模块化路由处理程序。Router 实例是完整的中间件和路由系统；因此，常常将其称为“微型应用程序”。  
以下示例将路由器创建为模块，在其中装入中间件，定义一些路由，然后安装在主应用程序的路径中。  
在应用程序目录中创建名为 birds.js 的路由器文件，其中包含以下内容：  

    var express = require('express');
    var router = express.Router();

    // middleware that is specific to this router
    router.use(function timeLog(req, res, next) {
        console.log('Time: ', Date.now());
        next();
    });
    // define the home page route
    router.get('/', function(req, res) {
        res.send('Birds home page');
    });
    // define the about route
    router.get('/about', function(req, res) {
        res.send('About birds');
    });

    module.exports = router;

接着，在应用程序中装入路由器模块：

    var birds = require('./birds');
    ...
    app.use('/birds', birds);

此应用程序现在可处理针对 /birds 和 /birds/about 的请求，调用特定于此路由的 timeLog 中间件函数。  



# 静态文件
为了提供诸如图像、CSS 文件和 JavaScript 文件之类的静态文件，请使用 Express 中的 express.static 内置中间件函数。  
将包含静态资源的目录的名称传递给 express.static 中间件函数，以便开始直接提供这些文件。  

    app.use(express.static('public'));

要使用多个静态资源目录，请多次调用 express.static 中间件函数：  

    app.use(express.static('public'));
    app.use(express.static('files'));

Express 以使用 express.static 中间件函数设置静态目录的顺序来查找文件。  
要为 express.static 函数提供的文件创建虚拟路径前缀（路径并不实际存在于文件系统中），请为静态目录指定安装路径，如下所示：  

    app.use('/static', express.static('public'));

# 404与错误处理
在 Express 中，404 响应不是错误的结果，所以错误处理程序中间件不会将其捕获。此行为是因为 404 响应只是表明缺少要执行的其他工作；换言之，Express 执行了所有中间件函数和路由，且发现它们都没有响应。您需要做的只是在堆栈的最底部（在其他所有函数之下）添加一个中间件函数来处理 404 响应：  

    app.use(function(req, res, next) {
        res.status(404).send('Sorry cant find that!');
    });

错误处理中间件的定义方式与其他中间件基本相同，差别在于错误处理中间件有四个自变量而不是三个，专门具有特征符 (err, req, res, next)：  

    app.use(function(err, req, res, next) {
        console.error(err.stack);
        res.status(500).send('Something broke!');
    });


# 中间件
Express 是一个路由和中间件 Web 框架，其自身只具有最低程度的功能：Express 应用程序基本上是一系列中间件函数调用。  
中间件函数能够访问请求对象 (req)、响应对象 (res) 以及应用程序的请求/响应循环中的下一个中间件函数。下一个中间件函数通常由名为 next 的变量来表示。  
中间件函数可以执行以下任务：  

1. 执行任何代码。
2. 对请求和响应对象进行更改。
3. 结束请求/响应循环。
4. 调用堆栈中的下一个中间件。

如果当前中间件函数没有结束请求/响应循环，那么它必须调用 next()，以将控制权传递给下一个中间件函数。否则，请求将保持挂起状态。  
![img](https://github.com/kerwenzhang/kerwenzhang.github.io/blob/master/_posts/image/express-mw.png?raw=true)  

Express 应用程序可以使用以下类型的中间件：  

    应用层中间件
    路由器层中间件
    错误处理中间件
    内置中间件
    第三方中间件

以下是我们之前写的“Hello World”Express 应用程序

    var express = require('express');
    var app = express();

    app.get('/', function (req, res) {
        res.send('Hello World!');
    });

    app.listen(3000);


以下是称为“myLogger”的中间件函数的简单示例

    var express = require('express');
    var app = express();

    var myLogger = function (req, res, next) {
        console.log('LOGGED');
        next();
    };

    app.use(myLogger);

    app.get('/', function (req, res) {
        res.send('Hello World!');
    });

    app.listen(3000);

应用程序每次收到请求时，会在终端上显示消息“LOGGED”。  
中间件装入顺序很重要：首先装入的中间件函数也首先被执行。如果在根路径的路由之后装入 myLogger，那么请求永远都不会到达该函数，应用程序也不会显示“LOGGED”，因为根路径的路由处理程序终止了请求/响应循环。  
下一个示例将名为 requestTime 的属性添加到请求对象。我们将此中间件函数命名为“requestTime”。  

    const express = require('express')
    const app = express()
    const port = 3000
    var birds = require('./birds');

    var myLogger = function(req, res, next){
        console.log('LOGGED');
        next();
    }
    var requestTime = function(req, res, next){
        req.requestTime = Date.now();
        next();
    }

    app.use(myLogger);
    app.use(requestTime);

    app.get('/', (req, res) => {
        var responseText = 'Hello World!';
        responseText += 'Requested at: ' + req.requestTime + '';
        res.send(responseText)
    })

## 路由器层中间件
路由器层中间件的工作方式与应用层中间件基本相同，差异之处在于它绑定到 express.Router() 的实例。  
使用 router.use() 和 router.METHOD() 函数装入路由器层中间件。  

    var app = express();
    var router = express.Router();

    // a middleware function with no mount path. This code is executed for every request to the router
    router.use(function (req, res, next) {
        console.log('Time:', Date.now());
        next();
    });

    // a middleware sub-stack shows request info for any type of HTTP request to the /user/:id path
    router.use('/user/:id', function(req, res, next) {
        console.log('Request URL:', req.originalUrl);
        next();
    }, function (req, res, next) {
        console.log('Request Type:', req.method);
    next();
    });

    // a middleware sub-stack that handles GET requests to the /user/:id path
    router.get('/user/:id', function (req, res, next) {
        // if the user ID is 0, skip to the next router
        if (req.params.id == 0) next('route');
        // otherwise pass control to the next middleware function in this stack
        else next(); //
    }, function (req, res, next) {
        // render a regular page
        res.render('regular');
    });

    // handler for the /user/:id path, which renders a special page
    router.get('/user/:id', function (req, res, next) {
        console.log(req.params.id);
        res.render('special');
    });

    // mount the router on the app
    app.use('/', router);


为了方便对路由进行模块化的管理，Express 不建议将路由直接挂载到 app 上，而是推荐将路由抽离为单独的模块。  
将路由抽离为单独模块的步骤如下：  
1. 创建路由模块对应的 .js 文件 router.js  
2. 调用 express.Router() 函数创建路由对象  
3. 向路由对象上挂载具体的路由  
4. 使用 module.exports 向外共享路由对象  
5. 使用 app.use() 函数注册路由模块  

## 错误处理中间件
错误处理中间件函数的定义方式与其他中间件函数基本相同，差别在于错误处理函数有四个自变量而不是三个，专门具有特征符 (err, req, res, next)：  

    app.use(function(err, req, res, next) {
        console.error(err.stack);
        res.status(500).send('Something broke!');
    });

请在其他 app.use() 和路由调用之后，最后定义错误处理中间件  

## 内置中间件
express.static(root, [options])  
Express 中唯一内置的中间件函数是 express.static。此函数基于 serve-static，负责提供 Express 应用程序的静态资源。  
root 自变量指定从其中提供静态资源的根目录。  

    app.use(express.static('public', options));

## 第三方中间件 
使用第三方中间件向 Express 应用程序添加功能。  
安装具有所需功能的 Node.js 模块，然后在应用层或路由器层的应用程序中将其加装入。  

    npm install cookie-parser

    var express = require('express');
    var app = express();
    var cookieParser = require('cookie-parser');

    // load the cookie-parsing middleware
    app.use(cookieParser());


# Reference
[Express 官网](https://expressjs.com/zh-cn/)  
[带你入门nodejs第三天——express路由](https://zhuanlan.zhihu.com/p/447486447)  
